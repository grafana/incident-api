// Code generated by oto; DO NOT EDIT.

// Package incident is a Go client library which makes it easy to
// interact with the Grafana Incident JSON/HTTP RPC API.
package incident

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// Client is used to access services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access.
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// BeforeRequest is an optional hook that gives you the opportunity
	// to inspect or modify the request before it is made.
	// Useful for adding auth headers, for example.
	// By default, it will add the Authorization header using the serviceAccountToken.
	BeforeRequest func(r *http.Request) error
	// Debug writes a line of debug log output.
	// No-op by default.
	Debug func(s string)

	// stubmode causes all the methods to return example data
	// without actually hitting the API. Useful for testing.
	stubmode bool
}

// NewClient makes a new Client.
// The remoteHost should be "https://your-stack.grafana.net/api/plugins/grafana-incident-app/resources/api/experimental"
// with `your-stack.grafana.net` pointing to your instance.
// The serviceAccountToken can be obtained from the Configuration via the web app
// (For more information, see https://grafana.com/docs/grafana-cloud/incident/api/experimental/auth/).
func NewClient(remoteHost, serviceAccountToken string) *Client {
	c := &Client{
		RemoteHost: remoteHost,
		Debug:      func(s string) { /* no-op by default */ },
		HTTPClient: &http.Client{Timeout: 60 * time.Second},
		stubmode:   false,
		BeforeRequest: func(r *http.Request) error {
			// add the Authorization header
			r.Header.Set("Authorization", "Bearer "+serviceAccountToken)
			return nil
		},
	}
	return c
}

// NewTestClient makes a new test Client that always returns the same
// data.
func NewTestClient() *Client {
	c := &Client{
		Debug:    func(s string) { /* no-op by default */ },
		stubmode: true,
	}
	return c
}

// AddLabelRequest is the request for the AddLabel call.
type AddLabelRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Label is the new label of the Incident.
	Label IncidentLabel `json:"label"`
}

// AddLabelResponse is the response for the AddLabel call.
type AddLabelResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

type AddTaskRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// Text is the todo item.
	Text string `json:"text"`

	// AssignToUserId is the user the task wil be assigned to
	AssignToUserId string `json:"assignToUserID"`
}

type AddTaskResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// AssignRoleRequest is the request for the AssignRole call.
type AssignRoleRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// UserID is the identifier of the person to assign the role to.
	UserID string `json:"userID"`

	// Role is the role of this person.
	Role string `json:"role"`
}

// AssignRoleResponse is the response for the AssignRole call.
type AssignRoleResponse struct {

	// Incident is the Incident that was just updated.
	Incident Incident `json:"incident"`

	// DidChange indicates if the role was changed or not. If the role was already
	// assigned, this will be false.
	DidChange bool `json:"didChange"`
}

// CreateIncidentRequest is the request for the CreateIncident call.
type CreateIncidentRequest struct {

	// Title is the headline title of the Incident. Shorter the better, but should
	// contain enough information to be able to identify and refer to this issue.
	Title string `json:"title"`

	// Severity expresses how bad the Incident is.
	Severity string `json:"severity"`

	// Labels are the labels associated with the Incident.
	Labels []IncidentLabel `json:"labels"`

	// RoomPrefix is the prefix that will be used to create the Incident room.
	RoomPrefix string `json:"roomPrefix"`

	// IsDrill indicates if the Incident is a drill or not. Incidents that are drills
	// do not show up in the dashboards, and may behave subtly differently in other
	// ways too. For example, during drills, more help might be offered to users.
	IsDrill bool `json:"isDrill"`

	// Status is the starting status of the Incident. Use "resolved" to open a
	// retrospective incident.
	Status string `json:"status"`

	// AttachCaption is the title of associated URL.
	AttachCaption string `json:"attachCaption"`

	// AttachURLis the associated URL.
	AttachURL string `json:"attachURL"`
}

// CreateIncidentResponse is the response for the CreateIncident call.
type CreateIncidentResponse struct {

	// Incident is the Incident that was created.
	Incident Incident `json:"incident"`
}

// Cursor describes the position in a result set. It is passed back into the same
// API to get the next page of results.
type Cursor struct {

	// NextValue is the start position of the next set of results. The implementation
	// may change, so clients should not rely on this value.
	NextValue string `json:"nextValue"`

	// HasMore indicates whether there are more results or not. If HasMore is true,
	// you can make the same request again (except using this Cursor instead) to get
	// the next page of results.
	HasMore bool `json:"hasMore"`
}

type DeleteTaskRequest struct {

	// IncidentID is the ID of the Incident.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the task.
	TaskID string `json:"taskID"`
}

type DeleteTaskResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// GetHomescreenVersionRequest is the request for the GetHomescreenVersion call.
type GetHomescreenVersionRequest struct {
}

// GetHomescreenVersionResponse is the response for the GetHomescreenVersion call.
type GetHomescreenVersionResponse struct {

	// Version is the refresh value of the home screen. A higher value than last time
	// indicates that the home screen should be refreshed.
	Version int `json:"version"`
}

// GetIncidentRequest is the request for the GetIncident call.
type GetIncidentRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`
}

// GetIncidentResponse is the response for the GetIncident call.
type GetIncidentResponse struct {

	// Incident is the Incident.
	Incident Incident `json:"incident"`
}

// GetIncidentVersionRequest is the request for the GetIncidentVersion call.
type GetIncidentVersionRequest struct {

	// IncidentID is the identifier of the Incident. A higher value than last time
	// indicates that the dashboard should be refreshed.
	IncidentID string `json:"incidentID"`
}

// GetIncidentVersionResponse is the response for the GetIncidentVersion call.
type GetIncidentVersionResponse struct {

	// Version is the refresh value of the Incident.
	Version int `json:"version"`
}

// Incident is a single incident.
type Incident struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// Severity expresses how bad the Incident is.
	Severity string `json:"severity"`

	// Labels is a list of strings associated with this Incident.
	Labels []IncidentLabel `json:"labels"`

	// IsDrill indicates if the Incident is a drill or not. Incidents that are drills
	// do not show up in the dashboards, and may behave subtly differently in other
	// ways too. For example, during drills, more help might be offered to users.
	IsDrill bool `json:"isDrill"`

	// CreatedTime is when the Incident was created.
	CreatedTime string `json:"createdTime"`

	// ModifiedTime is when the Incident was last modified.
	ModifiedTime string `json:"modifiedTime"`

	// CreatedByUser is the UserPreview that created the Incident.
	CreatedByUser UserPreview `json:"createdByUser"`

	// ClosedTime is when the Incident was closed.
	ClosedTime string `json:"closedTime"`

	// DurationSeconds is the number of seconds this Incident was (or is) open for.
	DurationSeconds int `json:"durationSeconds"`

	// Status is the current status of the Incident.
	Status string `json:"status"`

	// Title is the high level description of the Incident.
	Title string `json:"title"`

	// OverviewURL is the URL to the overview page for the Incident.
	OverviewURL string `json:"overviewURL"`

	// Roles describes the individuals involved in the Incident.
	Roles []IncidentRole `json:"roles"`

	// TaskList is the list of tasks associated with the Incident.
	TaskList TaskList `json:"taskList"`

	// Summary is as short recap of the Incident.
	Summary string `json:"summary"`

	// HeroImagePath is the path to the hero image for this Incident.
	HeroImagePath string `json:"heroImagePath"`

	// IncidentStart is when the Incident began.
	IncidentStart string `json:"incidentStart"`

	// IncidentEnd is when the Incident ended.
	IncidentEnd string `json:"incidentEnd"`
}

// IncidentLabel is a label associated with an Incident.
type IncidentLabel struct {

	// Label is the text of the label.
	Label string `json:"label"`

	// Description is a short explanation of the label.
	Description string `json:"description"`

	// Color is the CSS hex color of the label. Labels show up in both light and dark
	// modes, and this should be taken into consideration when selecting a color.
	ColorHex string `json:"colorHex"`
}

// IncidentRole represents a person involved in an Incident.
type IncidentRole struct {

	// Role is the unique name that describes the activity of the person.
	Role string `json:"role"`

	// Description is a short explanation of the role.
	Description string `json:"description"`

	// MaxPeople is the maximum number of people that can be assigned to this role.
	// If zero, then there is no limit. Usually it's 0 or 1.
	MaxPeople int `json:"maxPeople"`

	// Mandatory indicates if a Role is mandatory or not. Users will be bugged to fill
	// Mandatory roles.
	Mandatory bool `json:"mandatory"`

	// ImportantRole indicates if a role is important or not. Users in an important
	// role cannot be assigned to a non-important one.
	Important bool `json:"important"`

	// User is the person who holds this role.
	User UserPreview `json:"user"`
}

// IncidentsQuery is the query for the QueryIncidentsRequest.
type IncidentsQuery struct {

	// Limit is the number of Incidents to return.
	Limit int `json:"limit"`

	// IncludeStatuses is a list of statuses to include. Only Incidents with the listed
	// statuses will be returned.
	IncludeStatuses []string `json:"includeStatuses"`

	// ExcludeStatuses is a list of statuses to exclude. All Incidents that do not
	// match any of these values will be returned.
	ExcludeStatuses []string `json:"excludeStatuses"`

	// IncidentLabels is a list of labels to include. An empty list will not filter by
	// labels.
	IncidentLabels []string `json:"incidentLabels"`

	// DateFrom if is not empty would filter by the Incidents created since that date
	// (time.RFC3339)
	DateFrom string `json:"dateFrom"`

	// DateTo if is not empty would filter by incidents created before that date
	// (time.RFC3339)
	DateTo string `json:"dateTo"`

	// OnlyDrills if is not empty filters by whether an incident is a drill or not.
	OnlyDrills bool `json:"onlyDrills"`

	// OrderDirection is the direction to order the results.
	OrderDirection string `json:"orderDirection"`

	// Severity is a list of statuses to include. Only Incidents with the listed
	// statuses will be returned.
	Severity string `json:"severity"`

	// QueryString is the query string to search for. If provided, the query will be
	// filtered by the query string and the other query parameters will be ignored.
	QueryString string `json:"queryString"`
}

// OutgoingWebhookPayload represents the webhook HTTP POST body and contains
// metadata for the webhook.
type OutgoingWebhookPayload struct {

	// Version of this structure, following semantic versioning.
	Version string `json:"version"`

	// ID of event.
	ID string `json:"id"`

	// Source is a URI that identifies the context in which an event happened.
	Source string `json:"source"`

	// Time that event was generated (RFC 3339).
	Time string `json:"time"`

	// Event describes the (namespaced) event
	Event string `json:"event"`

	// Incident is the data payload, contains details about the data that was changed.
	Incident *Incident `json:"incident"`
}

// QueryIncidentsRequest is the request for the QueryIncidents call.
type QueryIncidentsRequest struct {

	// Query describes the query to make.
	Query IncidentsQuery `json:"query"`

	// Cursor is used to page through results. Empty for the first page. For subsequent
	// pages, use previously returned Cursor values.
	Cursor Cursor `json:"cursor"`
}

// QueryIncidentsResponse is the response for the QueryIncidents call.
type QueryIncidentsResponse struct {

	// Incidents is a list of Incidents.
	Incidents []Incident `json:"incidents"`

	// Query is the query that was used to generate this response.
	Query IncidentsQuery `json:"query"`

	// Cursor should be passed back to get the next page of results.
	Cursor Cursor `json:"cursor"`
}

// RemoveLabelRequest is the request for the RemoveLabel call.
type RemoveLabelRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Label is the new label of the Incident.
	Label IncidentLabel `json:"label"`
}

// RemoveLabelResponse is the response for the RemoveLabel call.
type RemoveLabelResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// Task is an individual task that somebody will do to resolve an Incident.
type Task struct {

	// TaskID is the ID of the task.
	TaskID string `json:"taskID"`

	// Immutable is true if the task cannot be changed. Used for tasks created and
	// maintained by the system (like role assignment tasks).
	Immutable bool `json:"immutable"`

	// CreatedTime is the time the task was created.
	CreatedTime string `json:"createdTime"`

	// ModifiedTime is the time
	ModifiedTime string `json:"modifiedTime"`

	// Text is the string that describes the Task.
	Text string `json:"text"`

	// Status os the status of this task.
	Status string `json:"status"`

	// AuthorUser is the person who created this task.
	AuthorUser *UserPreview `json:"authorUser"`

	// AssignedUser is the person this task is assigned to.
	AssignedUser *UserPreview `json:"assignedUser"`
}

// TaskList is a list of tasks.
type TaskList struct {

	// Tasks is a list of tasks.
	Tasks []Task `json:"tasks"`

	// TodoCount is the number of items in the list that are not yet done.
	TodoCount int `json:"todoCount"`

	// DoneCount is the number of items in the list that are done.
	DoneCount int `json:"doneCount"`
}

// UnassignRoleRequest is the request for the UnassignRole call.
type UnassignRoleRequest struct {

	// IncidentID is the identifier.
	IncidentID string `json:"incidentID"`

	// UserID is the identifier of the person to assign the role to.
	UserID string `json:"userID"`

	// Role is the role of this person.
	Role string `json:"role"`
}

// UnassignRoleResponse is the response for the UnassignRole call.
type UnassignRoleResponse struct {

	// Incident is the Incident that was just updated.
	Incident Incident `json:"incident"`

	// DidChange indicates if the role was changed or not. If the role was not
	// assigned, this will be false.
	DidChange bool `json:"didChange"`
}

// UpdateIncidentEventTimeRequest is the request for the UpdateIncidentEventTime
// call.
type UpdateIncidentEventTimeRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// EventTime is the new time for IncidentEnd or IncidentStart.
	EventTime string `json:"eventTime"`

	// ActivityItemKind is either the IncidentEnd or incidentStart time.
	ActivityItemKind string `json:"activityItemKind"`
}

type UpdateIncidentEventTimeResponse struct {
}

type UpdateIncidentIsDrillRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// IsDrill indicates whether the Incident is a drill or not.
	IsDrill bool `json:"isDrill"`
}

type UpdateIncidentIsDrillResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// UpdateSeverityRequest is the request for the UpdateSeverity call.
type UpdateSeverityRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Severity expresses how bad the Incident is.
	Severity string `json:"severity"`
}

// UpdateSeverityResponse is the response for the UpdateSeverity call.
type UpdateSeverityResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// UpdateStatusRequest is the request for the UpdateStatus call.
type UpdateStatusRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Status is the new status of the Incident.
	Status string `json:"status"`
}

// UpdateStatusResponse is the response for the UpdateStatus call.
type UpdateStatusResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

type UpdateTaskStatusRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the Task to update.
	TaskID string `json:"taskID"`

	// Status is the new status of this task.
	Status string `json:"status"`
}

type UpdateTaskStatusResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

type UpdateTaskTextRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the task.
	TaskID string `json:"taskID"`

	// Text is the string that describes the Task.
	Text string `json:"text"`
}

type UpdateTaskTextResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

type UpdateTaskUserRequest struct {

	// IncidentID is the ID of the Incident to add the Task to.
	IncidentID string `json:"incidentID"`

	// TaskID is the ID of the Task to update.
	TaskID string `json:"taskID"`

	// UserID is the ID of the User to assign to the Task.
	UserID string `json:"userID"`
}

type UpdateTaskUserResponse struct {

	// IncidentID is the ID of the incident these tasks relate to.
	IncidentID string `json:"incidentID"`

	// Task is the newly added Task. It will also appear in Tasks.
	Task Task `json:"task"`

	// TaskList is the tasks list.
	TaskList TaskList `json:"taskList"`
}

// UpdateTitleRequest is the request for the UpdateTitle call.
type UpdateTitleRequest struct {

	// IncidentID is the identifier of the Incident.
	IncidentID string `json:"incidentID"`

	// Title is the new title of the Incident.
	Title string `json:"title"`
}

// UpdateTitleResponse is the response for the UpdateTitle call.
type UpdateTitleResponse struct {

	// Incident is the Incident that was just modified.
	Incident Incident `json:"incident"`
}

// UserPreview is a user involved in an Incident.
type UserPreview struct {

	// UserID is the identifier for the user.
	UserID string `json:"userID"`

	// Name is a human readable string that represents the user.
	Name string `json:"name"`

	// PhotoURL is the URL to the profile picture of the user.
	PhotoURL string `json:"photoURL"`
}

// IncidentsService provides the ability to query, get, declare (create), update,
// and manage Incidents programatically. You can also manage roles and labels.
// Get one by calling NewIncidentsService.
type IncidentsService struct {
	client *Client
}

// NewIncidentsService gets a new IncidentsService.
func NewIncidentsService(client *Client) *IncidentsService {
	return &IncidentsService{
		client: client,
	}
}

// AddLabel adds a label to the Incident.
func (s *IncidentsService) AddLabel(ctx context.Context, r AddLabelRequest) (*AddLabelResponse, error) {
	if s.client.stubmode {
		return s.stubAddLabel()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: marshal AddLabelRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.AddLabel"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddLabelResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.AddLabel: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AddLabel: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.AddLabel: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.AddLabelResponse, nil
}

// AssignRole assigns a role to a user.
func (s *IncidentsService) AssignRole(ctx context.Context, r AssignRoleRequest) (*AssignRoleResponse, error) {
	if s.client.stubmode {
		return s.stubAssignRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: marshal AssignRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.AssignRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AssignRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.AssignRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.AssignRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.AssignRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.AssignRoleResponse, nil
}

// CreateIncident creates a new Incident.
func (s *IncidentsService) CreateIncident(ctx context.Context, r CreateIncidentRequest) (*CreateIncidentResponse, error) {
	if s.client.stubmode {
		return s.stubCreateIncident()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: marshal CreateIncidentRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.CreateIncident"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		CreateIncidentResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.CreateIncident: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.CreateIncident: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.CreateIncident: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.CreateIncidentResponse, nil
}

// GetIncident gets an existing Incident by ID.
func (s *IncidentsService) GetIncident(ctx context.Context, r GetIncidentRequest) (*GetIncidentResponse, error) {
	if s.client.stubmode {
		return s.stubGetIncident()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: marshal GetIncidentRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.GetIncident"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		GetIncidentResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.GetIncident: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.GetIncident: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.GetIncident: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.GetIncidentResponse, nil
}

// QueryIncidents gets a list of Incidents.
func (s *IncidentsService) QueryIncidents(ctx context.Context, r QueryIncidentsRequest) (*QueryIncidentsResponse, error) {
	if s.client.stubmode {
		return s.stubQueryIncidents()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: marshal QueryIncidentsRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.QueryIncidents"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		QueryIncidentsResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.QueryIncidents: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.QueryIncidents: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.QueryIncidents: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.QueryIncidentsResponse, nil
}

// RemoveLabel removes a label from the Incident.
func (s *IncidentsService) RemoveLabel(ctx context.Context, r RemoveLabelRequest) (*RemoveLabelResponse, error) {
	if s.client.stubmode {
		return s.stubRemoveLabel()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: marshal RemoveLabelRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.RemoveLabel"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		RemoveLabelResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.RemoveLabel: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.RemoveLabel: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.RemoveLabel: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.RemoveLabelResponse, nil
}

// UnassignRole removes a role assignment from a user.
func (s *IncidentsService) UnassignRole(ctx context.Context, r UnassignRoleRequest) (*UnassignRoleResponse, error) {
	if s.client.stubmode {
		return s.stubUnassignRole()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: marshal UnassignRoleRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UnassignRole"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UnassignRoleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UnassignRole: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UnassignRole: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UnassignRole: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UnassignRoleResponse, nil
}

// UpdateIncidentEventTime updates the start or end times of an Incident.
func (s *IncidentsService) UpdateIncidentEventTime(ctx context.Context, r UpdateIncidentEventTimeRequest) (*UpdateIncidentEventTimeResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateIncidentEventTime()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: marshal UpdateIncidentEventTimeRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateIncidentEventTime"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateIncidentEventTimeResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentEventTime: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateIncidentEventTimeResponse, nil
}

// UpdateIncidentIsDrill changes whether an Incident is a drill or not.
func (s *IncidentsService) UpdateIncidentIsDrill(ctx context.Context, r UpdateIncidentIsDrillRequest) (*UpdateIncidentIsDrillResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateIncidentIsDrill()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: marshal UpdateIncidentIsDrillRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateIncidentIsDrill"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateIncidentIsDrillResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateIncidentIsDrill: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateIncidentIsDrillResponse, nil
}

// UpdateSeverity updates the severity of an Incident.
func (s *IncidentsService) UpdateSeverity(ctx context.Context, r UpdateSeverityRequest) (*UpdateSeverityResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateSeverity()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: marshal UpdateSeverityRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateSeverity"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateSeverityResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateSeverity: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateSeverity: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateSeverity: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateSeverityResponse, nil
}

// UpdateStatus updates the status of an Incident.
func (s *IncidentsService) UpdateStatus(ctx context.Context, r UpdateStatusRequest) (*UpdateStatusResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateStatus()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: marshal UpdateStatusRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateStatus"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateStatusResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateStatus: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateStatus: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateStatus: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateStatusResponse, nil
}

// UpdateTitle updates the title of an Incident.
func (s *IncidentsService) UpdateTitle(ctx context.Context, r UpdateTitleRequest) (*UpdateTitleResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTitle()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: marshal UpdateTitleRequest: %w", err)
	}
	url := s.client.RemoteHost + "IncidentsService.UpdateTitle"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTitleResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("IncidentsService.UpdateTitle: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("IncidentsService.UpdateTitle: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("IncidentsService.UpdateTitle: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateTitleResponse, nil
}

// TasksService provides methods for managing tasks relating to Incidents.
// Get one by calling NewTasksService.
type TasksService struct {
	client *Client
}

// NewTasksService gets a new TasksService.
func NewTasksService(client *Client) *TasksService {
	return &TasksService{
		client: client,
	}
}

// AddTask adds a task to an Incident.
func (s *TasksService) AddTask(ctx context.Context, r AddTaskRequest) (*AddTaskResponse, error) {
	if s.client.stubmode {
		return s.stubAddTask()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: marshal AddTaskRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.AddTask"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		AddTaskResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.AddTask: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.AddTask: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.AddTask: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.AddTaskResponse, nil
}

// DeleteTask deletes a task.
func (s *TasksService) DeleteTask(ctx context.Context, r DeleteTaskRequest) (*DeleteTaskResponse, error) {
	if s.client.stubmode {
		return s.stubDeleteTask()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: marshal DeleteTaskRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.DeleteTask"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		DeleteTaskResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.DeleteTask: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.DeleteTask: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.DeleteTask: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.DeleteTaskResponse, nil
}

// UpdateTaskStatus updates the task's Status.
func (s *TasksService) UpdateTaskStatus(ctx context.Context, r UpdateTaskStatusRequest) (*UpdateTaskStatusResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTaskStatus()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: marshal UpdateTaskStatusRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.UpdateTaskStatus"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTaskStatusResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.UpdateTaskStatus: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskStatus: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.UpdateTaskStatus: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateTaskStatusResponse, nil
}

// UpdateTaskText updates the task's text.
func (s *TasksService) UpdateTaskText(ctx context.Context, r UpdateTaskTextRequest) (*UpdateTaskTextResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTaskText()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: marshal UpdateTaskTextRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.UpdateTaskText"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTaskTextResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.UpdateTaskText: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskText: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.UpdateTaskText: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateTaskTextResponse, nil
}

// UpdateTaskUser updates the task's assigned user. Passing an empty user ID will
// clear the assigned user.
func (s *TasksService) UpdateTaskUser(ctx context.Context, r UpdateTaskUserRequest) (*UpdateTaskUserResponse, error) {
	if s.client.stubmode {
		return s.stubUpdateTaskUser()
	}
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: marshal UpdateTaskUserRequest: %w", err)
	}
	url := s.client.RemoteHost + "TasksService.UpdateTaskUser"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: NewRequest: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	if s.client.BeforeRequest != nil {
		err = s.client.BeforeRequest(req)
		if err != nil {
			// don't wrap this error, it belongs to the user
			return nil, err
		}
	}
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: %w", err)
	}
	defer resp.Body.Close()
	var response struct {
		UpdateTaskUserResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("TasksService.UpdateTaskUser: new gzip reader: %w", err)
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := io.ReadAll(bodyReader)
	if err != nil {
		return nil, fmt.Errorf("TasksService.UpdateTaskUser: read response body: %w", err)
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("TasksService.UpdateTaskUser: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, fmt.Errorf(response.Error)
	}
	return &response.UpdateTaskUserResponse, nil
}

func (s *IncidentsService) stubAddLabel() (*AddLabelResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest AddLabelResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddLabel: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubAssignRole() (*AssignRoleResponse, error) {
	exampleJSON := `{
	"didChange": null,
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest AssignRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAssignRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubCreateIncident() (*CreateIncidentResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest CreateIncidentResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubCreateIncident: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubGetIncident() (*GetIncidentResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest GetIncidentResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubGetIncident: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubQueryIncidents() (*QueryIncidentsResponse, error) {
	exampleJSON := `{
	"cursor": {
		"hasMore": true,
		"nextValue": "aaaabbbbccccddddeeeeffffgggg"
	},
	"error": "something went wrong",
	"incidents": [
		{
			"closedTime": "2021-08-07T11:58:23Z",
			"createdByUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"createdTime": "2021-08-07T11:58:23Z",
			"durationSeconds": null,
			"heroImagePath": null,
			"incidentEnd": "2022-02-11 00:50:20.574137",
			"incidentID": "incident-123",
			"incidentStart": "2022-02-11 00:50:20.574137",
			"isDrill": false,
			"labels": [
				{
					"colorHex": "#ff0000",
					"description": "High latency in web requests",
					"label": "high-latency"
				},
				{
					"colorHex": "#ff0000",
					"description": "High latency in web requests",
					"label": "high-latency"
				}
			],
			"modifiedTime": "2021-08-07T11:58:23Z",
			"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
			"roles": [
				{
					"description": "Investigator searches for the problem and reports back.",
					"important": true,
					"mandatory": true,
					"maxPeople": 1,
					"role": "investigator",
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"description": "Investigator searches for the problem and reports back.",
					"important": true,
					"mandatory": true,
					"maxPeople": 1,
					"role": "investigator",
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"severity": "minor",
			"status": "active",
			"summary": null,
			"taskList": {
				"doneCount": 8,
				"tasks": [
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					},
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					}
				],
				"todoCount": 5
			},
			"title": "high latency in web requests"
		},
		{
			"closedTime": "2021-08-07T11:58:23Z",
			"createdByUser": {
				"name": "Morty Smith",
				"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
				"userID": "user-123"
			},
			"createdTime": "2021-08-07T11:58:23Z",
			"durationSeconds": null,
			"heroImagePath": null,
			"incidentEnd": "2022-02-11 00:50:20.574137",
			"incidentID": "incident-123",
			"incidentStart": "2022-02-11 00:50:20.574137",
			"isDrill": false,
			"labels": [
				{
					"colorHex": "#ff0000",
					"description": "High latency in web requests",
					"label": "high-latency"
				},
				{
					"colorHex": "#ff0000",
					"description": "High latency in web requests",
					"label": "high-latency"
				}
			],
			"modifiedTime": "2021-08-07T11:58:23Z",
			"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
			"roles": [
				{
					"description": "Investigator searches for the problem and reports back.",
					"important": true,
					"mandatory": true,
					"maxPeople": 1,
					"role": "investigator",
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				},
				{
					"description": "Investigator searches for the problem and reports back.",
					"important": true,
					"mandatory": true,
					"maxPeople": 1,
					"role": "investigator",
					"user": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					}
				}
			],
			"severity": "minor",
			"status": "active",
			"summary": null,
			"taskList": {
				"doneCount": 8,
				"tasks": [
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					},
					{
						"assignedUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"authorUser": {
							"name": "Morty Smith",
							"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
							"userID": "user-123"
						},
						"createdTime": "2018-01-01T00:00:00Z",
						"immutable": true,
						"modifiedTime": "2018-01-01T00:00:00Z",
						"status": "todo",
						"taskID": "task-123456",
						"text": "Assign an investigator"
					}
				],
				"todoCount": 5
			},
			"title": "high latency in web requests"
		}
	],
	"query": {
		"dateFrom": "2021-01-01T02:07:14+00:00",
		"dateTo": "2021-01-01T02:07:14+00:00",
		"excludeStatuses": [
			"closed"
		],
		"incidentLabels": [
			"security",
			"customersaffected"
		],
		"includeStatuses": [
			"active"
		],
		"limit": 10,
		"onlyDrills": true,
		"orderDirection": "ASC",
		"queryString": "isdrill:false any(label:security label:important)",
		"severity": "major"
	}
}`
	var dest QueryIncidentsResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubQueryIncidents: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubRemoveLabel() (*RemoveLabelResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest RemoveLabelResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubRemoveLabel: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUnassignRole() (*UnassignRoleResponse, error) {
	exampleJSON := `{
	"didChange": null,
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UnassignRoleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUnassignRole: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateIncidentEventTime() (*UpdateIncidentEventTimeResponse, error) {
	exampleJSON := `{
	"error": "something went wrong"
}`
	var dest UpdateIncidentEventTimeResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateIncidentEventTime: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateIncidentIsDrill() (*UpdateIncidentIsDrillResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateIncidentIsDrillResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateIncidentIsDrill: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateSeverity() (*UpdateSeverityResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateSeverityResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateSeverity: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateStatus() (*UpdateStatusResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateStatusResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateStatus: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *IncidentsService) stubUpdateTitle() (*UpdateTitleResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incident": {
		"closedTime": "2021-08-07T11:58:23Z",
		"createdByUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2021-08-07T11:58:23Z",
		"durationSeconds": null,
		"heroImagePath": null,
		"incidentEnd": "2022-02-11 00:50:20.574137",
		"incidentID": "incident-123",
		"incidentStart": "2022-02-11 00:50:20.574137",
		"isDrill": false,
		"labels": [
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			},
			{
				"colorHex": "#ff0000",
				"description": "High latency in web requests",
				"label": "high-latency"
			}
		],
		"modifiedTime": "2021-08-07T11:58:23Z",
		"overviewURL": "/a/grafana-incident-app/incidents/incident-123/title",
		"roles": [
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			},
			{
				"description": "Investigator searches for the problem and reports back.",
				"important": true,
				"mandatory": true,
				"maxPeople": 1,
				"role": "investigator",
				"user": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				}
			}
		],
		"severity": "minor",
		"status": "active",
		"summary": null,
		"taskList": {
			"doneCount": 8,
			"tasks": [
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				},
				{
					"assignedUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"authorUser": {
						"name": "Morty Smith",
						"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
						"userID": "user-123"
					},
					"createdTime": "2018-01-01T00:00:00Z",
					"immutable": true,
					"modifiedTime": "2018-01-01T00:00:00Z",
					"status": "todo",
					"taskID": "task-123456",
					"text": "Assign an investigator"
				}
			],
			"todoCount": 5
		},
		"title": "high latency in web requests"
	}
}`
	var dest UpdateTitleResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTitle: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubAddTask() (*AddTaskResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest AddTaskResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubAddTask: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubDeleteTask() (*DeleteTaskResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest DeleteTaskResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubDeleteTask: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubUpdateTaskStatus() (*UpdateTaskStatusResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest UpdateTaskStatusResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTaskStatus: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubUpdateTaskText() (*UpdateTaskTextResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest UpdateTaskTextResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTaskText: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

func (s *TasksService) stubUpdateTaskUser() (*UpdateTaskUserResponse, error) {
	exampleJSON := `{
	"error": "something went wrong",
	"incidentID": "incident-123456",
	"task": {
		"assignedUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"authorUser": {
			"name": "Morty Smith",
			"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
			"userID": "user-123"
		},
		"createdTime": "2018-01-01T00:00:00Z",
		"immutable": true,
		"modifiedTime": "2018-01-01T00:00:00Z",
		"status": "todo",
		"taskID": "task-123456",
		"text": "Assign an investigator"
	},
	"taskList": {
		"doneCount": 8,
		"tasks": [
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			},
			{
				"assignedUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"authorUser": {
					"name": "Morty Smith",
					"photoURL": "https://upload.wikimedia.org/wikipedia/en/c/c3/Morty_Smith.png",
					"userID": "user-123"
				},
				"createdTime": "2018-01-01T00:00:00Z",
				"immutable": true,
				"modifiedTime": "2018-01-01T00:00:00Z",
				"status": "todo",
				"taskID": "task-123456",
				"text": "Assign an investigator"
			}
		],
		"todoCount": 5
	}
}`
	var dest UpdateTaskUserResponse
	if err := json.Unmarshal([]byte(exampleJSON), &dest); err != nil {
		return nil, fmt.Errorf("stubUpdateTaskUser: json.Unmarshal: %w", err)
	}
	return &dest, nil
}

// Options contains constants to use for various fields across the API.
// It follows Options.{ObjectName}{FieldName}.{Option} structure, for example
// Options.IncidentSeverity.Pending.
var Options struct {

	// AssignRoleRequestRole contains the acceptable values for the
	// AssignRoleRequest.Role field.
	AssignRoleRequestRole struct {

		// Commander == "commander"
		Commander string

		// Investigator == "investigator"
		Investigator string

		// Observer == "observer"
		Observer string
	}

	// CreateIncidentRequestSeverity contains the acceptable values for the
	// CreateIncidentRequest.Severity field.
	CreateIncidentRequestSeverity struct {

		// Pending == "pending"
		Pending string

		// Minor == "minor"
		Minor string

		// Major == "major"
		Major string

		// Critical == "critical"
		Critical string
	}

	// CreateIncidentRequestStatus contains the acceptable values for the
	// CreateIncidentRequest.Status field.
	CreateIncidentRequestStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentSeverity contains the acceptable values for the
	// Incident.Severity field.
	IncidentSeverity struct {

		// Pending == "pending"
		Pending string

		// Minor == "minor"
		Minor string

		// Major == "major"
		Major string

		// Critical == "critical"
		Critical string
	}

	// IncidentStatus contains the acceptable values for the
	// Incident.Status field.
	IncidentStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentRoleRole contains the acceptable values for the
	// IncidentRole.Role field.
	IncidentRoleRole struct {

		// Commander == "commander"
		Commander string

		// Investigator == "investigator"
		Investigator string

		// Observer == "observer"
		Observer string
	}

	// IncidentsQueryIncludeStatuses contains the acceptable values for the
	// IncidentsQuery.IncludeStatuses field.
	IncidentsQueryIncludeStatuses struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentsQueryExcludeStatuses contains the acceptable values for the
	// IncidentsQuery.ExcludeStatuses field.
	IncidentsQueryExcludeStatuses struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// IncidentsQueryOrderDirection contains the acceptable values for the
	// IncidentsQuery.OrderDirection field.
	IncidentsQueryOrderDirection struct {

		// ASC == "ASC"
		ASC string

		// DESC == "DESC"
		DESC string
	}

	// TaskStatus contains the acceptable values for the
	// Task.Status field.
	TaskStatus struct {

		// Todo == "todo"
		Todo string

		// Progress == "progress"
		Progress string

		// Done == "done"
		Done string
	}

	// UnassignRoleRequestRole contains the acceptable values for the
	// UnassignRoleRequest.Role field.
	UnassignRoleRequestRole struct {

		// Commander == "commander"
		Commander string

		// Investigator == "investigator"
		Investigator string

		// Observer == "observer"
		Observer string
	}

	// UpdateIncidentEventTimeRequestActivityItemKind contains the acceptable values for the
	// UpdateIncidentEventTimeRequest.ActivityItemKind field.
	UpdateIncidentEventTimeRequestActivityItemKind struct {

		// IncidentEnd == "incidentEnd"
		IncidentEnd string

		// IncidentStart == "incidentStart"
		IncidentStart string
	}

	// UpdateSeverityRequestSeverity contains the acceptable values for the
	// UpdateSeverityRequest.Severity field.
	UpdateSeverityRequestSeverity struct {

		// Pending == "pending"
		Pending string

		// Minor == "minor"
		Minor string

		// Major == "major"
		Major string

		// Critical == "critical"
		Critical string
	}

	// UpdateStatusRequestStatus contains the acceptable values for the
	// UpdateStatusRequest.Status field.
	UpdateStatusRequestStatus struct {

		// Active == "active"
		Active string

		// Resolved == "resolved"
		Resolved string
	}

	// UpdateTaskStatusRequestStatus contains the acceptable values for the
	// UpdateTaskStatusRequest.Status field.
	UpdateTaskStatusRequestStatus struct {

		// Todo == "todo"
		Todo string

		// Progress == "progress"
		Progress string

		// Done == "done"
		Done string
	}
}

func init() {

	Options.AssignRoleRequestRole.Commander = "commander"

	Options.AssignRoleRequestRole.Investigator = "investigator"

	Options.AssignRoleRequestRole.Observer = "observer"

	Options.CreateIncidentRequestSeverity.Pending = "pending"

	Options.CreateIncidentRequestSeverity.Minor = "minor"

	Options.CreateIncidentRequestSeverity.Major = "major"

	Options.CreateIncidentRequestSeverity.Critical = "critical"

	Options.CreateIncidentRequestStatus.Active = "active"

	Options.CreateIncidentRequestStatus.Resolved = "resolved"

	Options.IncidentSeverity.Pending = "pending"

	Options.IncidentSeverity.Minor = "minor"

	Options.IncidentSeverity.Major = "major"

	Options.IncidentSeverity.Critical = "critical"

	Options.IncidentStatus.Active = "active"

	Options.IncidentStatus.Resolved = "resolved"

	Options.IncidentRoleRole.Commander = "commander"

	Options.IncidentRoleRole.Investigator = "investigator"

	Options.IncidentRoleRole.Observer = "observer"

	Options.IncidentsQueryIncludeStatuses.Active = "active"

	Options.IncidentsQueryIncludeStatuses.Resolved = "resolved"

	Options.IncidentsQueryExcludeStatuses.Active = "active"

	Options.IncidentsQueryExcludeStatuses.Resolved = "resolved"

	Options.IncidentsQueryOrderDirection.ASC = "ASC"

	Options.IncidentsQueryOrderDirection.DESC = "DESC"

	Options.TaskStatus.Todo = "todo"

	Options.TaskStatus.Progress = "progress"

	Options.TaskStatus.Done = "done"

	Options.UnassignRoleRequestRole.Commander = "commander"

	Options.UnassignRoleRequestRole.Investigator = "investigator"

	Options.UnassignRoleRequestRole.Observer = "observer"

	Options.UpdateIncidentEventTimeRequestActivityItemKind.IncidentEnd = "incidentEnd"

	Options.UpdateIncidentEventTimeRequestActivityItemKind.IncidentStart = "incidentStart"

	Options.UpdateSeverityRequestSeverity.Pending = "pending"

	Options.UpdateSeverityRequestSeverity.Minor = "minor"

	Options.UpdateSeverityRequestSeverity.Major = "major"

	Options.UpdateSeverityRequestSeverity.Critical = "critical"

	Options.UpdateStatusRequestStatus.Active = "active"

	Options.UpdateStatusRequestStatus.Resolved = "resolved"

	Options.UpdateTaskStatusRequestStatus.Todo = "todo"

	Options.UpdateTaskStatusRequestStatus.Progress = "progress"

	Options.UpdateTaskStatusRequestStatus.Done = "done"

}
